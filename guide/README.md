# Create a Huginn CVE Bot

### Prerequisites

This article assumes you already have a box set up with docker and docker-compose. Many people are familiar with docker, but less are familiar with docker-compose. I have put together an article that very quickly explains docker-compose and how I use it with Systemd below.

[Control Docker-Compose via Systemd](https://www.notion.so/Control-Docker-Compose-via-Systemd-5c7585a36f8c457ba3fceba30854ff3c?pvs=21)

If you aren’t familiar with docker, you can set everything described in this tutorial up on [Play with Docker](https://labs.play-with-docker.com) to test it before rolling it out on a permanent server. Do note that you should not have real secrets within Play with Docker, and if you enter a slack API URL, you should recreate it once you are finished with Play with Docker. I ran into an issue with Play with Docker that stated by disk was full. I’ve never seen this before, so you shouldn’t either, but if you do, just click the `Close Session` button and try again

### docker-compose.yml

As described in the article linked above, I created `/etc/docker/compose/huginn/docker-compose.yml` as seen below:

```jsx
version: "3.9"

services:
  web:
    image: huginn/huginn-single-process
    container_name: huginn-web
    depends_on:
      - db
    environment:
      DATABASE_ADAPTER:          mysql2
      DATABASE_HOST:             db
      DATABASE_PORT:             3306
      DATABASE_NAME:             ${MYSQL_DATABASE}
      DATABASE_USERNAME:         ${MYSQL_USER}
      DATABASE_PASSWORD:         ${MYSQL_PASSWORD}
      SEED_USERNAME:             ${HUGINN_USERNAME}
      SEED_PASSWORD:             ${HUGINN_PASSWORD}
      INVITATION_CODE:           ${HUGINN_INVITATION_CODE}
      RAILS_ENV:                 production
      DATABASE_ENCODING:         utf8mb4
      API_SECRET_TOKEN:          ${HUGINN_API_TOKEN}
    volumes:
      - config:/config
    ports:
      - 3000:3000
    restart: unless-stopped
  threads:
    image: huginn/huginn-single-process
    command: /scripts/init bin/threaded.rb
    container_name: huginn-threads
    depends_on:
      - web
      - db
    deploy:
    environment:
      DATABASE_ADAPTER:     mysql2
      DATABASE_HOST:        db
      DATABASE_PORT:        3306
      DATABASE_NAME:        ${MYSQL_DATABASE}
      DATABASE_USERNAME:    ${MYSQL_USER}
      DATABASE_PASSWORD:    ${MYSQL_PASSWORD}
      INVITATION_CODE:      ${HUGINN_INVITATION_CODE}
      RAILS_ENV:            production
      DATABASE_ENCODING:    utf8mb4
      API_SECRET_TOKEN:     ${HUGINN_API_TOKEN}
    volumes:
      - config:/config
    restart: unless-stopped
  db:
    image: mariadb:10
    restart: unless-stopped
    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
    volumes:
      - db:/var/lib/mysql
    environment:
      MYSQL_RANDOM_ROOT_PASSWORD: True
      MYSQL_PASSWORD:             ${MYSQL_PASSWORD}
      MYSQL_DATABASE:             ${MYSQL_DATABASE}
      MYSQL_USER:                 ${MYSQL_USER}

volumes:
  config:
  db:
```

There is also a `/etc/docker/compose/huginn/.env` file containing environmental variables used within the `docker-compose.yml` above. This looks like the following:

```jsx
MYSQL_DATABASE=huginn_db
MYSQL_USER=huginn_user
MYSQL_PASSWORD=huginn_pass_changeme
HUGINN_USERNAME=user
HUGINN_PASSWORD=changeme
HUGINN_INVITATION_CODE=changeme
HUGINN_API_TOKEN=changeme_random_string
```

Please note that there are a few items in here that should be changed as noted by `changeme`. The `HUGINN_INVITATION_CODE` is used to create additional accounts in huginn aside from the default `HUGINN_USERNAME` account, so make sure that’s not easily guessable. The `HUGINN_API_TOKEN` is allows external clients to reference Huginn data, so you will also want this to be not easily guessable. I use long random strings for both of these.

This is a very large docker-compose.yml file with quite a lot going on, so let’s take a closer look at it. It is responsible for creating three containers; `web`, `threads`, and `db`. `web` is responsible for hosting the actual web server, `threads` is responsible for running the Huginn Agents (i.e., tasks) we will be creating, and `db` is the mariadb database that will persist our data. There are also a few volumes, which will be stored persistently over at `/var/lib/docker/volumes/huginn_{config,db}` unless your docker is configured in a non-default way.

With those files in place, you should be able to execute `docker-compose up -d` (or `systemctl start docker-compose@huginn` if you followed my article linked at the top) to start everything up and access Huginn on port 3000.

It would also be a good time to mention that this configuration is using http over port 3000. I highly recommend that you put up something like an nginx reverse proxy with a valid TLS certificate if you’re exposing this to the internet or other untrusted network.

### Configure Huginn

With Huginn running, you can visit the ip and port to access it. You will first need to login with the credentials specified in the `.env` file (`HUGINN_USERNAME` and `HUGINN_PASSWORD`), which will bring you to Huginn itself.

![Untitled](images/Untitled.png)

The way that Huginn works is that we create “agents”, which react to conditions such as a certain amount of time passing, an API hook being called, or another agent calling it. There are 7 example agents by default. I will be deleting these to reduce the clutter.

![Untitled](images/Untitled%201.png)

There are a TON of different agent types and they can be used in a large variety of ways such as scraping websites, interacting with REST API’s or RSS Feeds, parsing data, formatting data, etc. We will be touching on a very small number of them here.

For the purpose of monitoring for new CVE’s that meet specific criteria, we will be creating the following agents that will all feed into each other in the following order:

- Rss Agent : Monitor VulDB Recent CVE’s
- Json Parse Agent : Get URL from VulDB RSS Feed
- Website Agent : Extract VulDB CVE Details
- Event Formatting Agent : Format CVE Message
- Trigger Agent : CVSS is Over 7.5
- Slack Agent : Notify Slack

### Monitor VulDB Recent CVE’s (RSS Agent)

Click `New Agent` on the `Agents Screen` seen above. Select `Rss Agent` as the `Type`.

Fill out the fields as seen here:

![Untitled](images/Untitled%202.png)

Note that if you click `Toggle View` under options, you have the ability to edit the raw JSON. This is a much easier format to share, so I will provide my raw JSON for each of the Agents here.

```jsx
{
  "expected_update_period_in_days": "2",
  "clean": "false",
  "url": "https://vuldb.com/?rss.recent"
}
```

Click `Dry Run`, and you should see a list of CVEs that have been posted recently.

![Untitled](images/Untitled%203.png)

This information will be passed into our next agent (aka our `Receiver`). Click `Save` and you will be returned to the list of Agents. I want to call attention to the `expected_update_period_in_days` field in the JSON. This is the maximum amount of time that the Agent should expect no updates to occur before it is flagged as `Not Working` in the `Your Agents` page.

![Untitled](images/Untitled%204.png)

After 5 minutes elapses (or you click Actions ⇒ Run), Working should change to `Yes` and you should see a number of `Events Created`. Each of these events will be passed to any `Receivers`, which we will create next. You can click on the number to inspect them or re-send (`Re-emit`) them to configured Receiv

![Untitled](images/Untitled%205.png)

### Get URL from VulDB Feed (JSON Parse Agent)

Create a new JSON Parse Agent like we did for the RSS Agent above and fill it out as follows:

![Untitled](images/Untitled%206.png)

Notice the `Propagate immediately` checkbox. By default, Huginn will batch events and execute them every minute. If you’re concerned about the timeliness of the reports, you can check this box to handle events the second they’re received.

Notice that we set our `Monitor VulDB Recent CVEs` as a `Source`. This means that we will receive events from that Agent, and use the content within this agent. As a reminder, the content from those events looks something like this:

```jsx
{
  "id": "https://vuldb.com/?id.215553",
  "url": "https://vuldb.com/?id.215553",
  "urls": [
    "https://vuldb.com/?id.215553"
  ],
  "links": [
    {
      "href": "https://vuldb.com/?id.215553"
    }
  ],
  "title": "CVE-2022-46345 | Siemens Parasolid X_B File out-of-bounds write (ssa-588101)",
  "description": "A vulnerability, which was classified as <a href=\"https://vuldb.com/?kb.risk\">critical<\/a>, was found in <a href=\"https://vuldb.com/?product.siemens:parasolid\">Siemens Parasolid<\/a>. This affects an unknown part of the component <em>X_B File Handler<\/em>. The manipulation leads to out-of-bounds write.\n\nThis vulnerability is uniquely identified as <a href=\"https://vuldb.com/?source_cve.215553\">CVE-2022-46345<\/a>. The attack can only be initiated within the local network. There is no exploit available.\n\nIt is recommended to upgrade the affected component.",
  "content": "A vulnerability, which was classified as <a href=\"https://vuldb.com/?kb.risk\">critical<\/a>, was found in <a href=\"https://vuldb.com/?product.siemens:parasolid\">Siemens Parasolid<\/a>. This affects an unknown part of the component <em>X_B File Handler<\/em>. The manipulation leads to out-of-bounds write.\n\nThis vulnerability is uniquely identified as <a href=\"https://vuldb.com/?source_cve.215553\">CVE-2022-46345<\/a>. The attack can only be initiated within the local network. There is no exploit available.\n\nIt is recommended to upgrade the affected component.",
  "image": null,
  "enclosure": null,
  "authors": [
    "<vuldb.com>"
  ],
  "categories": [
    "Vendor: Siemens",
    "Product: Parasolid",
    "Risk: critical",
    "Local: No",
    "Remote: Partially",
    "Exploit: No",
    "Countermeasures: Upgrade"
  ],
  "date_published": "2022-12-13T20:02:13+01:00",
  "last_updated": "2022-12-13T20:02:13+01:00"
}
```

It should be noted that there is some good information here and it would be exceptionally easy to extract, but we are still missing information about the CVSS score, so we will need to parse the full VulDB page for that information. Since we will be parsing the information for the full page anyway, I opted to just pull all the information from that page, even though it would be possible to grab some of it here and pass it forward. That may be a better way to go about it and I may explore that in the future.

Once configured, you can click `Dry Run` and select a `Recently received event` to test it.

![Untitled](images/Untitled%207.png)

![Untitled](images/Untitled%208.png)

### Extract VulDB CVE Details (Website Agent)

Now that we have our URL from the previous agent, we can create a Website Agent that will grab the content of that URL and parse it so that we can extract key bits of information. This is by far the most complex agent, and I don’t necessarily have it configured in the best possible way, so I encourage you to mess around with it to see if you can find more accurate ways to extract the desired information.

Create a Website Agent as we have done before and fill it out with the following information:

![Untitled](images/Untitled%209.png)

```jsx
{
  "expected_update_period_in_days": "2",
  "url_from_event": "{{ url }}",
  "type": "html",
  "mode": "on_change",
  "extract": {
    "cvss": {
      "css": ".vultop td:nth-child(1) span",
      "value": "string(.)"
    },
    "title": {
      "css": ".vulheader h1",
      "value": "string(.)"
    },
    "summary": {
      "xpath": "//*[@id=\"content\"]/article/div[2]/p[1]",
      "value": "string(.)"
    },
    "cve": {
      "css": ".vulheader div a:nth-child(2)",
      "value": "string(.)"
    },
    "product": {
      "css": ".productlist:last-of-type",
      "value": "string(.)"
    }
  },
  "template": {
    "url": "{{ url | to_uri: _response_.url }}"
  }
}
```

If you are familiar with web technology at all, you will recognize the format of the `css` and `xpath` fields. These are pretty temperamental, but I have found the following to be a pretty reasonable workflow to determine valid `css` paths:

1. Visit the URL and Right Click on some text you want to extract, then click Inspect
2. Determine whether the item has a `class` or `id` attribute we can use to reference it. If not, you will need to find the closest parent with one and drill down from there. Ideally, the text would have an `id` attribute, as those are intended to be unique and make extracting data from them incredibly easy (i.e., `#my-field`), but in the case of VulDB, they don’t use the `id` attribute a lot. Instead, they more heavily use the `class` attribute, which is less reliable and not intended to be unique. This can still be referenced with `.my-field` as seen above.
3. Switch to the `Console` tab and use `document.querySelectorAll(".my-class ...")` to help build your css. The result of that command must be a single item in an Array which is the HTML element containing your text. You should also use `document.querySelectorAll(".my-class ...")[0].innerText` to confirm that your css will function properly. In the following screenshot, you can see that I have determined that `.vultop td:nth-child(1) span` returns the CVSS score. If dealing with xpath, you can use something like `document.evaluate('//*[@id="content"]/article/div[2]/p[1]', document, null, XPathResult.STRING_TYPE).stringValue` to check what will be extracted.

![Untitled](images/Untitled%2010.png)

1. Attempt this command on several pages to ensure it works consistently. It is not the case that all VulDB pages have the same information or that it is accessible through the same CSS.

<aside>
💡 There is probably a better website to use the VulDB, but I was unable to find one that provided CVE information as quickly as VulDB.

</aside>

Use `Dry Run` again to confirm that everything is working as it should. If you have no `recently received events`, go back to the first agent and `re-emit` one. Note that if you did not check `propagate immediately`, it might take a few minutes to show up.

![Untitled](images/Untitled%2011.png)

![Untitled](images/Untitled%2012.png)

### Format CVE Message (Event Formatting Agent)

Now that we have the data we will include in our notification, we should pretty it up a bit using an Event Formatting Agent.

![Untitled](images/Untitled%2013.png)

```jsx
{
  "instructions": {
    "message": "{{ cve }} was just published with a CVSS of {{ cvss }}.<br><br>Product: {{ product }}<br>Summary: {{ summary }}<br><br>URL: {{ url }}",
    "subject": "{{ cve }} published with CVSS {{ cvss }}"
  },
  "matchers": [],
  "mode": "merge"
}
```

Pretty standard affair, but node the `mode` is set to `merge` and the use of double curly braces around some of the text. This agent uses Liquid formatting to extract the variables from the JSON it is passed and insert them into text and the `mode` signifies that it should take the JSON it was passed and add fields onto the JSON it will pass forward, rather than only passing forward our clean strings. This will allow us to keep the `cvss` field easily referable, so that we can use it to determine whether this is a CVE we care to notify about in the next Agent.

I also want to call attention to the usage of `<br>`. There are some complexities in passing around the data that make the `\n` line breaks that Slack wants incredibly annoying. We are using HTML line breaks here even though Slack doesn’t accept them. We will replace them with Slack friendly line breaks in the agent that actually sends the message.

Use Dry Run to ensure that your `message` and `subject` fields are as they should be and that the rest of the fields are still there. The output of slashes here will also lie to you. The only way to know if it is formatted properly (as far as I am aware) is to just throw it at Slack and see if it is happy. This is the most frustrating part of this setup and I don’t know of a better way to do it with Slack. Notification systems such as Email are much easier to work with as they can understand HTML like `<br>` which doesn’t have issues.

![Untitled](images/Untitled%2014.png)

### CVSS is Over 7.5 (Trigger Agent)

There are a TON of CVE’s released daily and we don’t want to be flooded with them, so we want some criteria to determine whether it is worth our time. In this example, we are only alerted if the CVSS is above 7.5, but you can determine what criteria is acceptable for you.

Create a Trigger Agent and fill it out as seen below:

```jsx
{
  "expected_receive_period_in_days": "2",
  "keep_event": "true",
  "rules": [
    {
      "type": "field>=value",
      "value": "7.5",
      "path": "cvss"
    }
  ]
}
```

![Untitled](images/Untitled%2015.png)

The logic here isn’t too hard to understand as it is simply saying “if the field at the given `path` is greater than or equal to the specified `value`, continue passing along the event”.

### Notify Slack (Slack Agent)

For our final Agent, we must create a Slack Agent as seen below, which will use a webhook we will create in a moment to send a message on the `#cve-notifications` channel of our Slack.

![Untitled](images/Untitled%2016.png)

```jsx
{
  "webhook_url": "https://hooks.slack.com/services/x/y/z",
  "channel": "#cve-notifications",
  "username": "Huginn",
  "message": "{{ message | replace: '<br>', '\\n' }}",
  "icon": ""
}
```

Notice that we are using the Liquid `replace` functionality to replace our HTML line breaks with slack friendly line breaks. I am doing this here instead of in the agent where we build the message above due to some issues with escape characters and passing around data via JSON. This is by far the easiest way to deal with Slack line breaks that I have found.

To create the `webhook_url`, follow the [official Slack Documentation](https://api.slack.com/messaging/webhooks) on [Sending Messages using Incoming Webhooks](https://api.slack.com/messaging/webhooks). I recommend creating a new Slack for this and a channel in that slack so that you avoid spamming the desired slack channel you will end up using. The steps are currently similar to the following:

1. Go to [https://api.slack.com/apps/](https://api.slack.com/apps/) and click `Create New App` ⇒ `From Scratch` and give it a name and workspace
2. Turn on `Incoming Webhooks` and click `Add New Webhook to Workspace` as seen below

![Untitled](images/Untitled%2017.png)

1. Select the channel you wish to post to and click `Allow`

![Untitled](images/Untitled%2018.png)

1. Copy the webhook URL and use it for the Agent

![Untitled](images/Untitled%2019.png)

### Test the Whole Workflow

You should now see something similar to the following on the `Your Agents` page.

![Untitled](images/Untitled%2020.png)

Click on the `Events Created` number for `Monitor VulDB Recent CVEs` and find an event that matches whatever criteria you set for notification (CVSS ≥ 7.5) and Re-emit it. If you are having trouble finding a good one, temporarily lower your acceptance criteria in the `Trigger Agent`.

Click `Re-emit` and give it some time. You can navigate to `/jobs` to it work through the various agents, which can take several minutes if you did not make use of `propagate immediately`.

![Untitled](images/Untitled%2021.png)

![Untitled](images/Untitled%2022.png)

You can also watch it work its way through at `/events`

![Untitled](images/Untitled%2023.png)

After the events are finished propagating, you will see a notification within the slack channel as seen below.

![Untitled](images/Untitled%2024.png)
